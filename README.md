# Цель: Сделать модели данных для сайта. 
На сайте есть список курсов, 
каждый курс ведет преподаватель, 
студент может записаться на курс. 
На курсе есть некоторое количество занятий по расписанию.


#### Для запуска проекта нужно клонировать репозиторий
* выполнить миграции используя `manage.py migrate`
* загрузить fixture коммандой `manage.py loaddata auth university`
* скомпилировать перевод `manage.py compilemessages`
* админка доступна по стандартному адресу, пользователь user, пароль 123
---
#### студент может записаться на курс используя метод enroll_in_a_course() модели Student

---
# Продолжение 2: 
#### Страницы для создания, удаления, редактирования, просмотра 1-го курса и списка курсов

---
# Продолжение 3:
#### Цель: Добавить страницу с контактами 
На странице создать форму для отправки сообщения.
После отправки формы отправлять письмо на почту администратора и второе письмо на почту указанную в форме.
Отправку писем реализовать через очередь задач.

### Результат:
Очередь задач на celery, в качестве брокера сообщений используется Redis

 * установить все зависимости из requirements.txt
 * установить Redis
 * запустить django проект
 * в виртуальном окружении проекта, запустить воркера celery `celery worker -A otus6 --loglevel=debug`
 * форма доступна по url /contacts/ или ссылке "Форма контактов" на главной
 
 ---
 # Продолжение 4:
 #### Цель: Научиться писать тесты и попробовать все виды тест-кейсов
1. Покрыть тестами все эндпоинты приложения
2. Использовать RequestFactory и APIClient
3. Использовать TransactionalTestCase, SimpleTestCase, APITestCase
4. Использовать setUp, setUpClass и setUpTestData методы

Критерии оценки: Эндпоинты корректно покрыты тестами
Все тесты проходят
Все описанные классы были использованы  

### Результат:
Созданы эндпоинты для 3 моделей и покрыты тестами, в соответствие заданным условиям

* необходимо выполнить миграции

# Продолжение 5:
#### Задание 1:
С помощью GraphQL создать схему, которая позволяет получать одновременно курсы, преподавателей и всех студентов записанных на курс

Схема добавлена, запрос выглядит примерно так
```
query {
  allCourses{
    title
    teachers{
      user{
        firstName
        lastName
      }
    }
    students{
      user{
        firstName
        lastName
      }    
    }
  }  
}
```
#### Задание 2:
Добавить Query для 3х моделей в проекте. Добавить мутацию для одной из моделей. Написать тесты для проверки работоспособности всех Query.

* query добавлены для моделей Course, Student, Teacher, UniversityUser
* Для модели UniversityUser добавлена мутация
* Написаны тесты для query 4 моделей и мутации

# Продолжение 6
#### Цель: Оптимизировать работу с базой данных, используя изученные средства. Написать отчет. Как было до оптимизации, какое средство использовалось, что стало после оптимизации
Включил логирование SQL запросов в консоль

---
Оптимизировал endpoint `/api/v1/course/'` 

было `queryset = Course.objects.all()`

стало `queryset = Course.objects.prefetch_related('teachers')`

на каждый запрошенный курс, дополнительно выполнялся запрос для получения teachers. 

После оптимизации выполняется 1 запрос для получения всех учителей выбранного набора курсов.

---
аналогичное действие проделано с endpoint `/api/v1/teacher/` все учителя с курсами получаются за 2 запроса

---
